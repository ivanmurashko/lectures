%% -*- coding:utf-8 -*- 
\section{Одноразовый блокнот}
\rindex{Одноразовый блокнот}
Схема одноразового блокнота была предложена в 1917 году Мэйджором
Дж. Моборном и Г. Вернамом. Классический одноразовый блокнот представляет собой
некоторый набор случайных ключей, каждый из которых равен по размеру
отправляемому сообщению и используется только один раз. 

Предположим что мы хотим зашифровать сообщение на некотором языке
(например на английском). Число символов (букв) которое используется в
алфавите обозначим через $X$. Для английского языка (без знаков
препинания и различия регистра) $X = 26$. Далее каждому из символов
языка мы назначим некоторое число $c$, такое что $0 \le c \le
X$. Например для английского языка можно записать
\begin{equation}
\begin{array}{c}
A \rightarrow 0 \\
B \rightarrow 1 \\
\dots \\
Z \rightarrow 25 \\
\end{array}
\nonumber
\end{equation}
  
Процедура шифрования \eqref{eqPart3CryptoEncryptClass} описывается
следующим выражением
\begin{equation}
E_{K_i}\left(P_i\right) = P_i + K_i \mod X = C_i,
\label{eqPart3CryptoEncryptVernam}
\end{equation}
где $i$ номер шифруемого символа.

Процедура дешифрования \eqref{eqPart3CryptoDeEncryptClass} описывается
следующим выражением
\begin{equation}
D_{K_i}\left(C_i\right) = C_i - K_i \mod X = P_i,
\label{eqPart3CryptoDeEncryptVernam}
\end{equation}
где $i$ номер шифруемого символа.

Эта процедура легко обобщается на случай двоичных данных, при этом
вместо сложения по модулю используется операция XOR ($a \oplus b$) как
для шифрования, так и для дешифрования :
\begin{table}
\centering
\begin{tabular}{|c|c|c|}
\hline
$a$ & $b$ & $a \oplus b$ \\ \hline
0  & 0 & 0 \\
0  & 1 & 1 \\
1  & 0 & 1 \\
1  & 1 & 0 \\ \hline
\end{tabular}
\caption{XOR $a \oplus b$}
\label{tblXOR}
\end{table}

Клод Шенон показал \cite{bShenonCrypto}, что если ключ действительно
случайный, имеет такую 
же длину, как исходное сообщение, и не используется повторно, то
предложенная 
схема одноразового блокнота абсолютно защищена.

Согласно Шенону абсолютная защищенность (perfect security) может быть
определена следующим образом.
\begin{definition}
Шифр $\left(E, D\right)$ абсолютно защищен если для любых двух
сообщений одинаковой длины $m_0$ и $m_1$, некоторого шифротекста $c$ и
ключа $k \leftarrow_R K$ вероятности того что исходный текст $m_0$ или
$m_1$ равны:
\begin{equation}
P\left(E\left(m_0, k\right) = c \right) = 
P\left(E\left(m_1, k\right) = c \right)
\nonumber
\end{equation}
\end{definition}
Перефразируя это определение можно сказать, что по исходной статистике
шифротекста невозможно получить никакой информации об исходном
сообщении. 

\begin{theorem}[Криптостойкость одноразового блокнота]
Схема одноразового блокнота имеет абсолютную защищенность.
\end{theorem}

\begin{proof}
Обозначим через $\left|K\right|$ - число всех возможных ключей длины
$l$. Где $l$ также длина исходных сообщений: $\left|m_{0,1}\right| =
l$. В силу того, что ключ которым зашифровано сообщение определяется
единственным образом:
\begin{equation}
k_{0,1} = c \oplus m_{0,1},
\nonumber
\end{equation} 
получаем для вероятностей
\begin{equation}
P\left(E\left(m_0, k\right) = c \right) = 
P\left(E\left(m_1, k\right) = c \right) = 
\frac{1}{\left|K\right|}.
\nonumber
\end{equation}
\end{proof}

\section{Проблемы классической криптографии}

Если существует абсолютно защищенная криптографическая система (одноразовый блокнот) то
что же не так в классической криптографии? Проблема заключается в
получении ключей, удовлетворяющих требованиям одноразового блокнота
(длина ключа равна длине сообщения, ключ состоит из случайных данных и
ни разу не используется повторно) и передачи этих ключей Бобу и Алисе.

Проблемы возникают как на этапе генерации ключей, \footnote{получение больших
последовательностей случайных чисел является не тривиальной
математической задачей} так и на этапе передачи этих ключей. 

Для передачи ключей в классической криптографии используются так
называемые алгоритмы с открытым ключом. Существует несколько
протоколов обмена ключей, основанных на криптографических системах с
открытым ключом. Все они основаны на том, что существует два ключа,
первый из которых, называемый открытым (public key), используется только
для зашифрования, а второй - закрытый (private key) для дешифрования. 
Для того чтобы получить закрытый ключ из открытого,
необходимо произвести какую-то сложную математическую
операцию. Например безопасность одной из наиболее популярных систем с
открытым ключом - RSA(см. \ref {AddRSA}),
\rindex{алгоритм RSA}
основана на трудности
факторизации\footnote{разложении на простые множители} больших чисел.

Схема протокола распределения ключа, основанная на криптографии с
открытым ключом, может быть описана следующим образом. На первом этапе
Алиса создает открытый и закрытый ключи и первый из них отсылает Бобу. 
Боб со своей стороны создает тот ключ, который хотелось бы иметь и
Алисе и Бобу (который требуется распределить). Этот ключ шифруется
(например по RSA) с помощью открытого ключа Алисы и пересылается
ей. Алиса, получая этот зашифрованный ключ, может расшифровать его с
помощью своего закрытого ключа.

Если злоумышленник (Ева) хочет узнать передаваемый ключ, она должна
решить сложную математическую задачу по факторизации больших
чисел. Считается, но не доказано, что сложность факторизации растет
экспоненциально с ростом числа цифр в числе
\cite{bPhisQuantInfo}.\footnote{Наиболее быстрый из известных
  алгоритмов решает задачу о факторизации числа $N$ за время порядка
  $O\left(exp\left(log^{\frac{1}{3}}N\left(log \, log N\right)^{\frac{2}{3}}\right)\right)$.} 
Таким образом при увеличении числа цифр задача быстро становится не решаемой.

В этой схеме имеется несколько проблем. Первая связана с тем что
сложность факторизации не доказана. Мало того, существуют алгоритмы для
квантовых компьютеров - алгоритм Шора(см. \ref {Part4QuantCompShor}),
которые решают задачу о факторизации числа $N$ за время $O\left(log
N\right)$, т. е. за время порядка числа цифр в $N$. Таким образом в
тот момент, когда будет построен квантовый компьютер, все системы,
основанные на RSA\rindex{алгоритм RSA}, утратят свою актуальность. 

%% Существует еще одна проблема которая делает системы распределения
%% ключа основанные на открытой криптографии незащищенными. Представим
%% себе ситуацию когда Ева может перехватывать все сообщения Алисы и Боба
%% и подменять их своими, что не является абсолютно нерешаемой задачей в
%% классической теории связи. В этом случае Ева может представиться Бобом для
%% Алисы и Алисой для Боба и таким образом полностью контролировать
%% передачу сообщений между ними и в момент пересылки ключа она сможет
%% его расшифровать. 
